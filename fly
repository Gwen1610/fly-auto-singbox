#!/usr/bin/env bash
set -euo pipefail

FLY_VERSION="0.3.0"
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="${ROOT_DIR}/config"
BUILD_DIR="${ROOT_DIR}/build"
SCRIPTS_DIR="${ROOT_DIR}/scripts"
ENV_FILE="${CONFIG_DIR}/fly.env"
ENV_EXAMPLE_FILE="${CONFIG_DIR}/fly.env.example"
PROVIDERS_FILE="${CONFIG_DIR}/extract.providers.json"
PROVIDERS_EXAMPLE_FILE="${CONFIG_DIR}/extract.providers.example.json"
ROUTE_RULES_FILE_DEFAULT="${CONFIG_DIR}/route-rules.json"
ROUTE_RULES_EXAMPLE_FILE="${CONFIG_DIR}/route-rules.example.json"

log() {
  printf '[fly] %s\n' "$*"
}

warn() {
  printf '[fly][warn] %s\n' "$*" >&2
}

die() {
  printf '[fly][error] %s\n' "$*" >&2
  exit 1
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "missing required command: $1"
}

is_true() {
  case "${1:-}" in
    1|true|TRUE|yes|YES|on|ON) return 0 ;;
    *) return 1 ;;
  esac
}

abs_path() {
  local path="$1"
  if [[ "${path}" = /* ]]; then
    printf '%s\n' "${path}"
  else
    printf '%s\n' "${ROOT_DIR}/${path#./}"
  fi
}

usage() {
  cat <<'EOF'
Fly - decoupled sing-box pipeline

Usage:
  ./fly init [--force]
  ./fly check-singbox
  ./fly install-singbox [--version v] [--os linux|darwin] [--arch amd64|arm64] [--install-dir dir] [--dry-run] [--force]
  ./fly install-guide
  ./fly extract
  ./fly build-config
  ./fly pipeline
  ./fly on
  ./fly off
  ./fly status
  ./fly log [-n lines] [--no-follow]
  ./fly help

Command summary:
  init          Create local runtime config files from templates
  check-singbox Show installed sing-box path and version
  install-singbox Auto download + install sing-box for linux/mac
  install-guide  Alias of install-singbox --dry-run
  extract       Extract region nodes only (US/HK/SG/JP, no route rules)
  build-config  Build final config.json by injecting route rules into extracted nodes
  pipeline      Run extract + build-config
  on            Start sing-box in background (nohup + PID file)
  off           Stop sing-box using PID file (with pkill fallback)
  status        Show running status from PID file
  log           Tail sing-box log file
  help          Show this help
EOF
}

backup_existing_file() {
  local file="$1"
  [[ -f "${file}" ]] || return 0
  mkdir -p "${BUILD_DIR}/backup"
  local backup_file="${BUILD_DIR}/backup/$(basename "${file}").bak.$(date +%Y%m%d%H%M%S)"
  cp "${file}" "${backup_file}"
  log "backup ${file} -> ${backup_file}"
}

load_env() {
  if [[ -f "${ENV_FILE}" ]]; then
    # shellcheck disable=SC1090
    source "${ENV_FILE}"
  else
    warn "missing ${ENV_FILE}; using built-in defaults (run ./fly init to generate files)"
  fi

  : "${PYTHON_BIN:=python3}"
  : "${SING_BOX_BIN:=sing-box}"
  if [[ -z "${SUDO_BIN+x}" ]]; then
    SUDO_BIN="sudo"
  fi
  : "${EXTRACT_PROVIDERS_FILE:=./config/extract.providers.json}"
  : "${NODES_FILE:=./build/nodes.json}"
  : "${ROUTE_RULES_FILE:=./config/route-rules.json}"
  : "${BASE_TEMPLATE_FILE:=./config/base-template.json}"
  : "${CONFIG_JSON:=./config.json}"
  : "${PID_FILE:=./.sing-box.pid}"
  : "${LOG_FILE:=./sing-box.log}"
  : "${SINGBOX_VERSION:=1.12.20}"
  : "${SINGBOX_INSTALL_DIR:=/usr/local/bin}"
  : "${SINGBOX_RELEASES_API:=https://api.github.com/repos/SagerNet/sing-box/releases}"

  EXTRACT_PROVIDERS_FILE="$(abs_path "${EXTRACT_PROVIDERS_FILE}")"
  NODES_FILE="$(abs_path "${NODES_FILE}")"
  ROUTE_RULES_FILE="$(abs_path "${ROUTE_RULES_FILE}")"
  BASE_TEMPLATE_FILE="$(abs_path "${BASE_TEMPLATE_FILE}")"
  CONFIG_JSON="$(abs_path "${CONFIG_JSON}")"
  PID_FILE="$(abs_path "${PID_FILE}")"
  LOG_FILE="$(abs_path "${LOG_FILE}")"
}

detect_os() {
  case "$(uname -s)" in
    Linux) printf 'linux\n' ;;
    Darwin) printf 'darwin\n' ;;
    *) die "unsupported OS: $(uname -s)" ;;
  esac
}

detect_arch() {
  case "$(uname -m)" in
    x86_64|amd64) printf 'amd64\n' ;;
    aarch64|arm64) printf 'arm64\n' ;;
    *) die "unsupported architecture: $(uname -m)" ;;
  esac
}

resolve_release_asset() {
  local version="$1"
  local target_os="$2"
  local target_arch="$3"
  local releases_file="$4"
  python3 - "${version}" "${target_os}" "${target_arch}" "${releases_file}" <<'PY'
import json
import sys
from pathlib import Path

version = sys.argv[1]
target_os = sys.argv[2]
target_arch = sys.argv[3]
releases = json.loads(Path(sys.argv[4]).read_text(encoding="utf-8"))

if not isinstance(releases, list):
    raise SystemExit("unexpected releases API response")

target_release = None
if version == "latest":
    for rel in releases:
        if not rel.get("prerelease"):
            target_release = rel
            break
else:
    wanted = version.lstrip("v")
    for rel in releases:
        tag = str(rel.get("tag_name", "")).lstrip("v")
        if tag == wanted:
            target_release = rel
            break

if not target_release:
    raise SystemExit(f"cannot find release for version: {version}")

asset_url = ""
asset_name = ""
needle = f"{target_os}-{target_arch}"
for asset in target_release.get("assets", []):
    name = str(asset.get("name", ""))
    if needle in name and name.endswith(".tar.gz"):
        asset_name = name
        asset_url = str(asset.get("browser_download_url", ""))
        break

if not asset_url:
    raise SystemExit(f"no {needle} .tar.gz asset found in {target_release.get('tag_name')}")

print(str(target_release.get("tag_name", "")))
print(asset_name)
print(asset_url)
PY
}

normalize_version() {
  local raw="$1"
  raw="${raw#v}"
  printf '%s' "${raw}" | sed -E 's/^[^0-9]*([0-9]+\.[0-9]+\.[0-9]+([.-][A-Za-z0-9]+)?)?.*$/\1/'
}

resolve_singbox_binary_path() {
  local configured="${SING_BOX_BIN}"
  local resolved=""
  if [[ "${configured}" == */* ]]; then
    resolved="$(abs_path "${configured}")"
    if [[ -x "${resolved}" ]]; then
      printf '%s\n' "${resolved}"
      return 0
    fi
  else
    resolved="$(command -v "${configured}" 2>/dev/null || true)"
    if [[ -n "${resolved}" ]]; then
      printf '%s\n' "${resolved}"
      return 0
    fi
  fi

  if [[ "${configured}" != "sing-box" ]]; then
    resolved="$(command -v sing-box 2>/dev/null || true)"
    if [[ -n "${resolved}" ]]; then
      printf '%s\n' "${resolved}"
      return 0
    fi
  fi

  resolved="${SINGBOX_INSTALL_DIR%/}/sing-box"
  if [[ -x "${resolved}" ]]; then
    printf '%s\n' "${resolved}"
    return 0
  fi
  return 1
}

get_singbox_installed_info() {
  local path=""
  path="$(resolve_singbox_binary_path || true)"
  if [[ -z "${path}" ]]; then
    return 1
  fi
  local ver_line=""
  ver_line="$("${path}" version 2>/dev/null | head -n 1 || true)"
  local norm_ver=""
  norm_ver="$(normalize_version "${ver_line}")"
  printf '%s\n' "${path}"
  printf '%s\n' "${ver_line}"
  printf '%s\n' "${norm_ver}"
}

run_as_sudo() {
  if [[ -n "${SUDO_BIN}" ]]; then
    "${SUDO_BIN}" "$@"
  else
    "$@"
  fi
}

ensure_sudo_ticket() {
  if [[ -n "${SUDO_BIN}" ]]; then
    "${SUDO_BIN}" -v
  fi
}

pid_is_alive() {
  local pid="$1"
  [[ "${pid}" =~ ^[0-9]+$ ]] || return 1
  if [[ -n "${SUDO_BIN}" ]]; then
    "${SUDO_BIN}" kill -0 "${pid}" >/dev/null 2>&1
  else
    kill -0 "${pid}" >/dev/null 2>&1
  fi
}

read_pid_file() {
  [[ -f "${PID_FILE}" ]] || return 1
  local pid
  pid="$(cat "${PID_FILE}" 2>/dev/null || true)"
  [[ "${pid}" =~ ^[0-9]+$ ]] || return 1
  printf '%s\n' "${pid}"
}

init_files() {
  local force="false"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force|-f) force="true" ;;
      *) die "unknown flag for init: $1" ;;
    esac
    shift
  done

  mkdir -p "${CONFIG_DIR}" "${BUILD_DIR}" "${SCRIPTS_DIR}"

  if [[ ! -f "${ENV_EXAMPLE_FILE}" ]]; then
    die "missing template: ${ENV_EXAMPLE_FILE}"
  fi
  if [[ ! -f "${PROVIDERS_EXAMPLE_FILE}" ]]; then
    die "missing template: ${PROVIDERS_EXAMPLE_FILE}"
  fi
  if [[ ! -f "${ROUTE_RULES_EXAMPLE_FILE}" ]]; then
    die "missing template: ${ROUTE_RULES_EXAMPLE_FILE}"
  fi

  if [[ ! -f "${ENV_FILE}" ]] || is_true "${force}"; then
    if [[ -f "${ENV_FILE}" ]]; then
      backup_existing_file "${ENV_FILE}"
    fi
    cp "${ENV_EXAMPLE_FILE}" "${ENV_FILE}"
    log "generated ${ENV_FILE}"
  else
    log "exists ${ENV_FILE}, skip"
  fi

  if [[ ! -f "${PROVIDERS_FILE}" ]] || is_true "${force}"; then
    if [[ -f "${PROVIDERS_FILE}" ]]; then
      backup_existing_file "${PROVIDERS_FILE}"
    fi
    cp "${PROVIDERS_EXAMPLE_FILE}" "${PROVIDERS_FILE}"
    log "generated ${PROVIDERS_FILE}"
  else
    log "exists ${PROVIDERS_FILE}, skip"
  fi

  if [[ ! -f "${ROUTE_RULES_FILE_DEFAULT}" ]] || is_true "${force}"; then
    if [[ -f "${ROUTE_RULES_FILE_DEFAULT}" ]]; then
      backup_existing_file "${ROUTE_RULES_FILE_DEFAULT}"
    fi
    cp "${ROUTE_RULES_EXAMPLE_FILE}" "${ROUTE_RULES_FILE_DEFAULT}"
    log "generated ${ROUTE_RULES_FILE_DEFAULT}"
  else
    log "exists ${ROUTE_RULES_FILE_DEFAULT}, skip"
  fi

  log "init complete"
}

cmd_install_singbox() {
  load_env
  local version="${SINGBOX_VERSION}"
  local target_os=""
  local target_arch=""
  local install_dir="${SINGBOX_INSTALL_DIR}"
  local dry_run="false"
  local force_install="false"
  local releases_file=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --version)
        shift
        [[ $# -gt 0 ]] || die "missing value for --version"
        version="$1"
        ;;
      --os)
        shift
        [[ $# -gt 0 ]] || die "missing value for --os"
        target_os="$1"
        ;;
      --arch)
        shift
        [[ $# -gt 0 ]] || die "missing value for --arch"
        target_arch="$1"
        ;;
      --install-dir)
        shift
        [[ $# -gt 0 ]] || die "missing value for --install-dir"
        install_dir="$1"
        ;;
      --dry-run)
        dry_run="true"
        ;;
      --force)
        force_install="true"
        ;;
      --releases-json)
        shift
        [[ $# -gt 0 ]] || die "missing value for --releases-json"
        releases_file="$(abs_path "$1")"
        ;;
      *)
        die "unknown flag for install-singbox: $1"
        ;;
    esac
    shift
  done

  [[ -n "${target_os}" ]] || target_os="$(detect_os)"
  [[ -n "${target_arch}" ]] || target_arch="$(detect_arch)"
  [[ "${target_os}" =~ ^(linux|darwin)$ ]] || die "unsupported --os: ${target_os}"
  [[ "${target_arch}" =~ ^(amd64|arm64)$ ]] || die "unsupported --arch: ${target_arch}"

  local tmp_dir
  tmp_dir="$(mktemp -d)"
  trap 'rm -rf "${tmp_dir:-}"' RETURN

  if [[ -z "${releases_file}" ]]; then
    need_cmd curl
    releases_file="${tmp_dir}/releases.json"
    curl -fsSL "${SINGBOX_RELEASES_API}" -o "${releases_file}"
  else
    [[ -f "${releases_file}" ]] || die "missing releases JSON file: ${releases_file}"
  fi

  local release_meta release_tag asset_name asset_url
  release_meta="$(resolve_release_asset "${version}" "${target_os}" "${target_arch}" "${releases_file}")"
  release_tag="$(printf '%s\n' "${release_meta}" | sed -n '1p')"
  asset_name="$(printf '%s\n' "${release_meta}" | sed -n '2p')"
  asset_url="$(printf '%s\n' "${release_meta}" | sed -n '3p')"

  local installed_path="" installed_line="" installed_norm=""
  local info=""
  info="$(get_singbox_installed_info || true)"
  if [[ -n "${info}" ]]; then
    installed_path="$(printf '%s\n' "${info}" | sed -n '1p')"
    installed_line="$(printf '%s\n' "${info}" | sed -n '2p')"
    installed_norm="$(printf '%s\n' "${info}" | sed -n '3p')"
  fi
  local release_norm
  release_norm="$(normalize_version "${release_tag}")"
  local will_skip="false"
  if [[ -n "${installed_norm}" ]] && [[ "${installed_norm}" == "${release_norm}" ]] && ! is_true "${force_install}"; then
    will_skip="true"
  fi

  if is_true "${dry_run}"; then
    cat <<EOF
[dry-run] sing-box install plan
release_tag=${release_tag}
asset=${asset_name}
url=${asset_url}
install_dir=${install_dir}
sudo=${SUDO_BIN:-<none>}
installed_path=${installed_path:-<none>}
installed_version=${installed_norm:-<unknown>}
will_skip=${will_skip}
EOF
    trap - RETURN
    rm -rf "${tmp_dir}"
    return 0
  fi

  if is_true "${will_skip}"; then
    log "sing-box already installed: ${installed_path} (${installed_norm}), skip download (use --force to reinstall)"
    trap - RETURN
    rm -rf "${tmp_dir}"
    return 0
  fi

  need_cmd curl
  need_cmd tar
  need_cmd install

  local tarball="${tmp_dir}/sing-box.tar.gz"
  log "downloading ${asset_name}"
  curl -fsSL "${asset_url}" -o "${tarball}"
  tar -xzf "${tarball}" -C "${tmp_dir}"

  local binary_path
  binary_path="$(find "${tmp_dir}" -type f -name sing-box | head -n 1 || true)"
  [[ -n "${binary_path}" ]] || die "cannot find sing-box binary in downloaded archive"

  if [[ -n "${SUDO_BIN}" ]]; then
    "${SUDO_BIN}" install -d "${install_dir}"
    "${SUDO_BIN}" install -m 755 "${binary_path}" "${install_dir}/sing-box"
  else
    install -d "${install_dir}"
    install -m 755 "${binary_path}" "${install_dir}/sing-box"
  fi

  log "installed sing-box -> ${install_dir}/sing-box"
  "${install_dir}/sing-box" version || true
  trap - RETURN
  rm -rf "${tmp_dir}"
}

cmd_check_singbox() {
  load_env
  local info=""
  info="$(get_singbox_installed_info || true)"
  if [[ -z "${info}" ]]; then
    printf 'not installed\n'
    return 0
  fi
  local installed_path installed_line installed_norm
  installed_path="$(printf '%s\n' "${info}" | sed -n '1p')"
  installed_line="$(printf '%s\n' "${info}" | sed -n '2p')"
  installed_norm="$(printf '%s\n' "${info}" | sed -n '3p')"
  printf 'installed_path=%s\n' "${installed_path}"
  printf 'version_line=%s\n' "${installed_line:-<unknown>}"
  printf 'version=%s\n' "${installed_norm:-<unknown>}"
}

cmd_install_guide() {
  cmd_install_singbox --dry-run "$@"
}

cmd_extract() {
  load_env
  need_cmd "${PYTHON_BIN}"
  [[ -f "${EXTRACT_PROVIDERS_FILE}" ]] || die "missing providers config: ${EXTRACT_PROVIDERS_FILE}"

  mkdir -p "$(dirname "${NODES_FILE}")"
  "${PYTHON_BIN}" "${SCRIPTS_DIR}/extract_nodes.py" \
    --providers-file "${EXTRACT_PROVIDERS_FILE}" \
    --output-file "${NODES_FILE}"
  log "extracted nodes -> ${NODES_FILE}"
}

cmd_build_config() {
  load_env
  need_cmd "${PYTHON_BIN}"
  [[ -f "${NODES_FILE}" ]] || die "missing nodes file: ${NODES_FILE} (run ./fly extract first)"
  [[ -f "${ROUTE_RULES_FILE}" ]] || die "missing route rules file: ${ROUTE_RULES_FILE}"
  [[ -f "${BASE_TEMPLATE_FILE}" ]] || die "missing base template: ${BASE_TEMPLATE_FILE}"

  "${PYTHON_BIN}" "${SCRIPTS_DIR}/build_config.py" \
    --nodes-file "${NODES_FILE}" \
    --rules-file "${ROUTE_RULES_FILE}" \
    --template-file "${BASE_TEMPLATE_FILE}" \
    --output-file "${CONFIG_JSON}"
  log "generated config -> ${CONFIG_JSON}"
}

cmd_pipeline() {
  cmd_extract
  cmd_build_config
}

cmd_on() {
  load_env
  [[ -f "${CONFIG_JSON}" ]] || die "missing ${CONFIG_JSON}; run ./fly build-config first"
  need_cmd nohup
  need_cmd "${SING_BOX_BIN}"

  local old_pid=""
  if old_pid="$(read_pid_file)" && pid_is_alive "${old_pid}"; then
    printf 'already running (pid: %s)\n' "${old_pid}"
    return 0
  fi

  ensure_sudo_ticket
  mkdir -p "$(dirname "${PID_FILE}")" "$(dirname "${LOG_FILE}")"

  local start_cmd
  printf -v start_cmd 'nohup %q run -c %q > %q 2>&1 & echo $! > %q' \
    "${SING_BOX_BIN}" "${CONFIG_JSON}" "${LOG_FILE}" "${PID_FILE}"

  if [[ -n "${SUDO_BIN}" ]]; then
    "${SUDO_BIN}" sh -c "${start_cmd}"
  else
    sh -c "${start_cmd}"
  fi

  sleep 1
  local new_pid
  new_pid="$(read_pid_file || true)"
  [[ -n "${new_pid}" ]] || die "failed to write PID file: ${PID_FILE}"
  if ! pid_is_alive "${new_pid}"; then
    die "process failed to start (pid=${new_pid}); check ${LOG_FILE}"
  fi
  printf 'started (pid: %s)\n' "${new_pid}"
  printf 'log: %s\n' "${LOG_FILE}"
}

cmd_off() {
  load_env
  local stopped="false"
  local pid=""

  if pid="$(read_pid_file)" && pid_is_alive "${pid}"; then
    run_as_sudo kill "${pid}" >/dev/null 2>&1 || true
    local _i
    for _i in 1 2 3 4 5; do
      if ! pid_is_alive "${pid}"; then
        break
      fi
      sleep 1
    done
    if pid_is_alive "${pid}"; then
      run_as_sudo kill -9 "${pid}" >/dev/null 2>&1 || true
    fi
    stopped="true"
  fi

  rm -f "${PID_FILE}"

  if [[ "${stopped}" != "true" ]]; then
    if run_as_sudo pkill -f "sing-box run -c ${CONFIG_JSON}" >/dev/null 2>&1; then
      stopped="true"
    fi
  fi

  if [[ "${stopped}" == "true" ]]; then
    printf 'stopped\n'
  else
    printf 'not running\n'
  fi
}

cmd_status() {
  load_env
  local pid=""
  if pid="$(read_pid_file)" && pid_is_alive "${pid}"; then
    printf 'running (pid: %s)\n' "${pid}"
  else
    printf 'not running\n'
  fi
}

cmd_log() {
  load_env
  local lines="200"
  local follow="true"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n|--lines)
        shift
        [[ $# -gt 0 ]] || die "missing value for --lines"
        lines="$1"
        ;;
      --no-follow)
        follow="false"
        ;;
      *)
        die "unknown flag for log: $1"
        ;;
    esac
    shift
  done

  [[ -f "${LOG_FILE}" ]] || die "missing log file: ${LOG_FILE}"
  if is_true "${follow}"; then
    tail -n "${lines}" -f "${LOG_FILE}"
  else
    tail -n "${lines}" "${LOG_FILE}"
  fi
}

main() {
  local cmd="${1:-help}"
  shift || true

  case "${cmd}" in
    init) init_files "$@" ;;
    check-singbox) cmd_check_singbox "$@" ;;
    install-singbox) cmd_install_singbox "$@" ;;
    install-guide) cmd_install_guide "$@" ;;
    extract) cmd_extract "$@" ;;
    build-config) cmd_build_config "$@" ;;
    pipeline) cmd_pipeline "$@" ;;
    on) cmd_on "$@" ;;
    off) cmd_off "$@" ;;
    status) cmd_status "$@" ;;
    log) cmd_log "$@" ;;
    help|-h|--help) usage ;;
    version|-v|--version)
      printf '%s\n' "${FLY_VERSION}"
      ;;
    *)
      die "unknown command: ${cmd}. Run ./fly help"
      ;;
  esac
}

main "$@"
