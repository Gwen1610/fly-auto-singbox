#!/usr/bin/env bash
set -euo pipefail

FLY_VERSION="0.2.0"
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="${ROOT_DIR}/config"
BUILD_DIR="${ROOT_DIR}/build"
SCRIPTS_DIR="${ROOT_DIR}/scripts"
ENV_FILE="${CONFIG_DIR}/fly.env"
ENV_EXAMPLE_FILE="${CONFIG_DIR}/fly.env.example"
PROVIDERS_FILE="${CONFIG_DIR}/extract.providers.json"
PROVIDERS_EXAMPLE_FILE="${CONFIG_DIR}/extract.providers.example.json"

log() {
  printf '[fly] %s\n' "$*"
}

warn() {
  printf '[fly][warn] %s\n' "$*" >&2
}

die() {
  printf '[fly][error] %s\n' "$*" >&2
  exit 1
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "missing required command: $1"
}

is_true() {
  case "${1:-}" in
    1|true|TRUE|yes|YES|on|ON) return 0 ;;
    *) return 1 ;;
  esac
}

abs_path() {
  local path="$1"
  if [[ "${path}" = /* ]]; then
    printf '%s\n' "${path}"
  else
    printf '%s\n' "${ROOT_DIR}/${path#./}"
  fi
}

usage() {
  cat <<'EOF'
Fly - decoupled sing-box pipeline

Usage:
  ./fly init [--force]
  ./fly install-guide
  ./fly extract
  ./fly build-config
  ./fly pipeline
  ./fly on
  ./fly off
  ./fly status
  ./fly log [-n lines] [--no-follow]
  ./fly help

Command summary:
  init          Create local runtime config files from templates
  install-guide Print manual sing-box download/install commands (no auto install)
  extract       Use sing-box-subscribe to extract region nodes only (no route rules)
  build-config  Build final config.json by injecting route rules into extracted nodes
  pipeline      Run extract + build-config
  on            Start sing-box in background (nohup + PID file)
  off           Stop sing-box using PID file (with pkill fallback)
  status        Show running status from PID file
  log           Tail sing-box log file
  help          Show this help
EOF
}

backup_existing_file() {
  local file="$1"
  [[ -f "${file}" ]] || return 0
  mkdir -p "${BUILD_DIR}/backup"
  local backup_file="${BUILD_DIR}/backup/$(basename "${file}").bak.$(date +%Y%m%d%H%M%S)"
  cp "${file}" "${backup_file}"
  log "backup ${file} -> ${backup_file}"
}

load_env() {
  if [[ -f "${ENV_FILE}" ]]; then
    # shellcheck disable=SC1090
    source "${ENV_FILE}"
  else
    warn "missing ${ENV_FILE}; using built-in defaults (run ./fly init to generate files)"
  fi

  : "${SUBSCRIBE_DIR:=../sing-box-subscribe}"
  : "${PYTHON_BIN:=python3}"
  : "${SING_BOX_BIN:=sing-box}"
  if [[ -z "${SUDO_BIN+x}" ]]; then
    SUDO_BIN="sudo"
  fi
  : "${EXTRACT_PROVIDERS_FILE:=./config/extract.providers.json}"
  : "${NODES_FILE:=./build/nodes.json}"
  : "${ROUTE_RULES_FILE:=./config/route-rules.json}"
  : "${BASE_TEMPLATE_FILE:=./config/base-template.json}"
  : "${CONFIG_JSON:=./config.json}"
  : "${PID_FILE:=./.sing-box.pid}"
  : "${LOG_FILE:=./sing-box.log}"
  : "${SINGBOX_VERSION:=1.12.20}"

  SUBSCRIBE_DIR="$(abs_path "${SUBSCRIBE_DIR}")"
  EXTRACT_PROVIDERS_FILE="$(abs_path "${EXTRACT_PROVIDERS_FILE}")"
  NODES_FILE="$(abs_path "${NODES_FILE}")"
  ROUTE_RULES_FILE="$(abs_path "${ROUTE_RULES_FILE}")"
  BASE_TEMPLATE_FILE="$(abs_path "${BASE_TEMPLATE_FILE}")"
  CONFIG_JSON="$(abs_path "${CONFIG_JSON}")"
  PID_FILE="$(abs_path "${PID_FILE}")"
  LOG_FILE="$(abs_path "${LOG_FILE}")"
}

run_as_sudo() {
  if [[ -n "${SUDO_BIN}" ]]; then
    "${SUDO_BIN}" "$@"
  else
    "$@"
  fi
}

ensure_sudo_ticket() {
  if [[ -n "${SUDO_BIN}" ]]; then
    "${SUDO_BIN}" -v
  fi
}

pid_is_alive() {
  local pid="$1"
  [[ "${pid}" =~ ^[0-9]+$ ]] || return 1
  if [[ -n "${SUDO_BIN}" ]]; then
    "${SUDO_BIN}" kill -0 "${pid}" >/dev/null 2>&1
  else
    kill -0 "${pid}" >/dev/null 2>&1
  fi
}

read_pid_file() {
  [[ -f "${PID_FILE}" ]] || return 1
  local pid
  pid="$(cat "${PID_FILE}" 2>/dev/null || true)"
  [[ "${pid}" =~ ^[0-9]+$ ]] || return 1
  printf '%s\n' "${pid}"
}

init_files() {
  local force="false"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force|-f) force="true" ;;
      *) die "unknown flag for init: $1" ;;
    esac
    shift
  done

  mkdir -p "${CONFIG_DIR}" "${BUILD_DIR}" "${SCRIPTS_DIR}"

  if [[ ! -f "${ENV_EXAMPLE_FILE}" ]]; then
    die "missing template: ${ENV_EXAMPLE_FILE}"
  fi
  if [[ ! -f "${PROVIDERS_EXAMPLE_FILE}" ]]; then
    die "missing template: ${PROVIDERS_EXAMPLE_FILE}"
  fi

  if [[ ! -f "${ENV_FILE}" ]] || is_true "${force}"; then
    if [[ -f "${ENV_FILE}" ]]; then
      backup_existing_file "${ENV_FILE}"
    fi
    cp "${ENV_EXAMPLE_FILE}" "${ENV_FILE}"
    log "generated ${ENV_FILE}"
  else
    log "exists ${ENV_FILE}, skip"
  fi

  if [[ ! -f "${PROVIDERS_FILE}" ]] || is_true "${force}"; then
    if [[ -f "${PROVIDERS_FILE}" ]]; then
      backup_existing_file "${PROVIDERS_FILE}"
    fi
    cp "${PROVIDERS_EXAMPLE_FILE}" "${PROVIDERS_FILE}"
    log "generated ${PROVIDERS_FILE}"
  else
    log "exists ${PROVIDERS_FILE}, skip"
  fi

  log "init complete"
}

cmd_install_guide() {
  load_env
  local arch
  case "$(uname -m)" in
    x86_64|amd64) arch="amd64" ;;
    aarch64|arm64) arch="arm64" ;;
    *) arch="<amd64|arm64>" ;;
  esac

  cat <<EOF
# Manual sing-box installation guide (same download path as old flow)

VERSION="${SINGBOX_VERSION}"
ARCH="${arch}"

# 1) Download tarball from official GitHub Releases
curl -fL "https://github.com/SagerNet/sing-box/releases/download/v\${VERSION}/sing-box-\${VERSION}-linux-\${ARCH}.tar.gz" -o /tmp/sing-box.tar.gz

# 2) Extract and install binary
tar -xzf /tmp/sing-box.tar.gz -C /tmp
sudo install -m 755 "\$(find /tmp -type f -name sing-box | head -n 1)" /usr/local/bin/sing-box

# 3) Verify
sing-box version
EOF
}

cmd_extract() {
  load_env
  need_cmd "${PYTHON_BIN}"
  [[ -d "${SUBSCRIBE_DIR}" ]] || die "sing-box-subscribe directory not found: ${SUBSCRIBE_DIR}"
  [[ -f "${SUBSCRIBE_DIR}/main.py" ]] || die "missing ${SUBSCRIBE_DIR}/main.py"
  [[ -f "${EXTRACT_PROVIDERS_FILE}" ]] || die "missing providers config: ${EXTRACT_PROVIDERS_FILE}"

  mkdir -p "$(dirname "${NODES_FILE}")"
  "${PYTHON_BIN}" "${SCRIPTS_DIR}/extract_nodes.py" \
    --subscribe-dir "${SUBSCRIBE_DIR}" \
    --providers-file "${EXTRACT_PROVIDERS_FILE}" \
    --output-file "${NODES_FILE}"
  log "extracted nodes -> ${NODES_FILE}"
}

cmd_build_config() {
  load_env
  need_cmd "${PYTHON_BIN}"
  [[ -f "${NODES_FILE}" ]] || die "missing nodes file: ${NODES_FILE} (run ./fly extract first)"
  [[ -f "${ROUTE_RULES_FILE}" ]] || die "missing route rules file: ${ROUTE_RULES_FILE}"
  [[ -f "${BASE_TEMPLATE_FILE}" ]] || die "missing base template: ${BASE_TEMPLATE_FILE}"

  "${PYTHON_BIN}" "${SCRIPTS_DIR}/build_config.py" \
    --nodes-file "${NODES_FILE}" \
    --rules-file "${ROUTE_RULES_FILE}" \
    --template-file "${BASE_TEMPLATE_FILE}" \
    --output-file "${CONFIG_JSON}"
  log "generated config -> ${CONFIG_JSON}"
}

cmd_pipeline() {
  cmd_extract
  cmd_build_config
}

cmd_on() {
  load_env
  [[ -f "${CONFIG_JSON}" ]] || die "missing ${CONFIG_JSON}; run ./fly build-config first"
  need_cmd nohup
  need_cmd "${SING_BOX_BIN}"

  local old_pid=""
  if old_pid="$(read_pid_file)" && pid_is_alive "${old_pid}"; then
    printf 'already running (pid: %s)\n' "${old_pid}"
    return 0
  fi

  ensure_sudo_ticket
  mkdir -p "$(dirname "${PID_FILE}")" "$(dirname "${LOG_FILE}")"

  local start_cmd
  printf -v start_cmd 'nohup %q run -c %q > %q 2>&1 & echo $! > %q' \
    "${SING_BOX_BIN}" "${CONFIG_JSON}" "${LOG_FILE}" "${PID_FILE}"

  if [[ -n "${SUDO_BIN}" ]]; then
    "${SUDO_BIN}" sh -c "${start_cmd}"
  else
    sh -c "${start_cmd}"
  fi

  sleep 1
  local new_pid
  new_pid="$(read_pid_file || true)"
  [[ -n "${new_pid}" ]] || die "failed to write PID file: ${PID_FILE}"
  if ! pid_is_alive "${new_pid}"; then
    die "process failed to start (pid=${new_pid}); check ${LOG_FILE}"
  fi
  printf 'started (pid: %s)\n' "${new_pid}"
  printf 'log: %s\n' "${LOG_FILE}"
}

cmd_off() {
  load_env
  local stopped="false"
  local pid=""

  if pid="$(read_pid_file)" && pid_is_alive "${pid}"; then
    run_as_sudo kill "${pid}" >/dev/null 2>&1 || true
    local _i
    for _i in 1 2 3 4 5; do
      if ! pid_is_alive "${pid}"; then
        break
      fi
      sleep 1
    done
    if pid_is_alive "${pid}"; then
      run_as_sudo kill -9 "${pid}" >/dev/null 2>&1 || true
    fi
    stopped="true"
  fi

  rm -f "${PID_FILE}"

  if [[ "${stopped}" != "true" ]]; then
    if run_as_sudo pkill -f "sing-box run -c ${CONFIG_JSON}" >/dev/null 2>&1; then
      stopped="true"
    fi
  fi

  if [[ "${stopped}" == "true" ]]; then
    printf 'stopped\n'
  else
    printf 'not running\n'
  fi
}

cmd_status() {
  load_env
  local pid=""
  if pid="$(read_pid_file)" && pid_is_alive "${pid}"; then
    printf 'running (pid: %s)\n' "${pid}"
  else
    printf 'not running\n'
  fi
}

cmd_log() {
  load_env
  local lines="200"
  local follow="true"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n|--lines)
        shift
        [[ $# -gt 0 ]] || die "missing value for --lines"
        lines="$1"
        ;;
      --no-follow)
        follow="false"
        ;;
      *)
        die "unknown flag for log: $1"
        ;;
    esac
    shift
  done

  [[ -f "${LOG_FILE}" ]] || die "missing log file: ${LOG_FILE}"
  if is_true "${follow}"; then
    tail -n "${lines}" -f "${LOG_FILE}"
  else
    tail -n "${lines}" "${LOG_FILE}"
  fi
}

main() {
  local cmd="${1:-help}"
  shift || true

  case "${cmd}" in
    init) init_files "$@" ;;
    install-guide) cmd_install_guide "$@" ;;
    extract) cmd_extract "$@" ;;
    build-config) cmd_build_config "$@" ;;
    pipeline) cmd_pipeline "$@" ;;
    on) cmd_on "$@" ;;
    off) cmd_off "$@" ;;
    status) cmd_status "$@" ;;
    log) cmd_log "$@" ;;
    help|-h|--help) usage ;;
    version|-v|--version)
      printf '%s\n' "${FLY_VERSION}"
      ;;
    *)
      die "unknown command: ${cmd}. Run ./fly help"
      ;;
  esac
}

main "$@"
